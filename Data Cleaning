{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 0,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "FIT7z_rydwlD"
   },
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import warnings\n",
    "import datetime\n",
    "\n",
    "%matplotlib inline\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "\n",
    "may = pd.read_csv('May.csv',delimiter=';',encoding='iso8859_7').drop(0).drop(columns=['Unnamed: 0', '_id'])\n",
    "june = pd.read_csv('June.csv',delimiter=';',encoding='iso8859_7').drop(0).drop(columns=['Unnamed: 0', '_id'])\n",
    "july = pd.read_csv('July.csv',delimiter=';',encoding='iso8859_7').drop(0).drop(columns=['Unnamed: 0', '_id', 'fan_speed_perc_pv', 'fan_speed_perc_sp', 'bf_dp_mbar_sp', 'is_enable_sp', 'is_clicked_sp'])\n",
    "aug = pd.read_csv('August.csv',delimiter=';',encoding='iso8859_7').drop(0).drop(columns=['Unnamed: 0', '_id', 'fan_speed_perc_sp', 'bf_dp_mbar_sp', 'is_enable_sp', 'is_clicked_sp'])\n",
    "sep = pd.read_csv('September.csv',delimiter=';',encoding='iso8859_7').drop(0).drop(columns=['Unnamed: 0', '_id', 'fan_speed_perc_sp', 'bf_dp_mbar_sp', 'is_enable_sp', 'is_clicked_sp'])\n",
    "octo = pd.read_csv('October.csv',delimiter=';',encoding='iso8859_7').drop(0).drop(columns=['Unnamed: 0', '_id', 'fan_speed_perc_sp', 'bf_dp_mbar_sp', 'is_enable_sp', 'is_clicked_sp'])\n",
    "\n",
    "months = pd.Series([may, june, july, aug, sep, octo])\n",
    "\n",
    "#το pq μας νοιάζει κυρίως: άμα θές να δείς τις διαφορές μεταξύ των ονομάτων των στηλών του μα΄ϊου και του ιουλίου πχ πατας pq[2]\n",
    "p = pd.Series([])\n",
    "q = pd.Series([])\n",
    "pq = pd.Series([])\n",
    "\n",
    "#αυτό είναι το καινούριο \"λεξικό\" που θα φτιάξουμε ώστε να αντικαταστήσουμε τα λάθος ονόματα στις στήλες\n",
    "dct = pd.Series([])\n",
    "\n",
    "#κάποιες μάσκες που χρησιμοποιώ παρακάτω // bma = backslash, main, addition\n",
    "month_mask = pd.Series([])\n",
    "bma_mask = pd.Series([])\n",
    "pres_mask = pd.Series([])\n",
    "error_mask = pd.Series([])\n",
    "zero_mask = pd.Series([])\n",
    "nan_mask = pd.Series([])\n",
    "\n",
    "for i in range(6):\n",
    "    #μετατροπη σε datetime, έλεγχος για το μήνα, αλλάγη μήνα-μέρα\n",
    "    #πρεπει να βρουμε τροπο να δουμε αν εχει γινει παντου σωστα\n",
    "    months[i]['date'] = pd.to_datetime(months[i]['date'], errors='coerce', dayfirst=True)\n",
    "    month_mask[i] = months[i]['date'].apply(lambda e: e.month)==i+5\n",
    "    months[i]['date'][month_mask[i]==False] = months[i]['date'][month_mask[i]==False].apply(lambda x: datetime.datetime.strftime(x, '%Y-%d-%m %H:%M:%S'))\n",
    "    months[i]['date'] = pd.to_datetime(months[i]['date'], errors='coerce', dayfirst=True)\n",
    "    \n",
    "    #sorting + indexifying\n",
    "    #το sorting μπορει και να μην πρεπει να γινει ακομα...(?)\n",
    "    months[i] = months[i].sort_values(by = 'date')\n",
    "    months[i].set_index('date', inplace=True)\n",
    "    \n",
    "    #υπηρχαν καποιες γραμμες που εχουν ΜΟΝΟ error και τιποτα αλλο, αυτες εφυγαν\n",
    "    #οσες εχουν σε καποιο σημειο error αλλα πληροφοριες παντου αλλου τις εκανα None ωστε \n",
    "    #να τα διαχειριστούμε μαζί με τα υπόλοιπα missing values\n",
    "    #ΙΔΕΑ: να βαλουμε καποιο threshhold για τα errors και να σβησουμε γραμμες που \n",
    "    #πανω απο το 75% πχ των πληροφοριών είναι errors;\n",
    "    #δε νομιζω οτι υπαρχουν τετοιες γραμμες, αλλα ισως και να εχει νοημα να το κανουμε \n",
    "    #δεν ξερω πως βεβαια :P\n",
    "    #αλλαγη όλων των τιμών σε float:\n",
    "    \n",
    "    error_mask[i] = months[i]['mill_operation']!='ERROR'\n",
    "    months[i] = months[i][error_mask[i]]\n",
    "    \n",
    "    for col in months[i].columns:\n",
    "        months[i][col] = pd.to_numeric(months[i][col], errors='coerce')\n",
    "    months[i].dropna(axis=0, how='all', inplace=True)\n",
    "    \n",
    "    zero_mask[i] = months[i]['mill_operation']!=0\n",
    "    months[i] = months[i][zero_mask[i]]\n",
    "    \n",
    "    nan_mask[i] = months[i]['mill_operation'].notna()\n",
    "    months[i] = months[i][nan_mask[i]]\n",
    "    \n",
    "    #αυτο το κομματι κωδικα αν το ξανατρεξουμε ξεχωριστα σε αλλο κελι θα γραψει απο πανω τον προηγουμενο pq \n",
    "    #και δε θα φαινονται πια ολες οι διαφορες που προϋπήρχαν, αλλά μονο οι 4-5 extra στήλες \n",
    "    #που δεν υπαρχουν στους 2 πρωτους μηνες\n",
    "    #μπορειτε να τρεξετε αυτο το κελι, μετα πχ το pq[3], μετα αυτόν τον κώδικα σε άλλο κελι και μετά πάλι το pq[3] \n",
    "    #και θα καταλάβετε τι εννοω\n",
    "    #ΣΗΜΕΙΩΣΗ: στον ιουλιο παραμενουν 5 στηλες ενω στους 3 τελευταιους μηνες παραμενουν 4 στηλες παραπανω...καμια ιδεα;;\n",
    "    #για να το δειτε καντε τα παραπανω και μετα πατηστε pq[2] και μετα pq[3 ή 4 ή 5]\n",
    "    p[i] = pd.Series([])\n",
    "    p[i] = months[0].columns[months[0].columns.isin(months[i].columns)==False]\n",
    "    q[i] = pd.Series([])\n",
    "    q[i] = months[i].columns[months[i].columns.isin(months[0].columns)==False]\n",
    "    pq[i] = pd.DataFrame([p[i], q[i]])\n",
    "    \n",
    "    #συμφωνα με μια συζητηση που ειχαμε και κοιτωντας τα pq αναλυτικα ειδαμε οτι οι μονες διαφορες ειναι οι παρακατω\n",
    "    bma_mask[i] = pq[i].iloc[0].apply(lambda x: (('/' in x) or ('main' in x) or ('addition' in x)) if (x!=None) else False)\n",
    "    pres_mask[i] = pq[i].iloc[0].apply(lambda x: ('pres' in x and 'press' not in x) if (x!=None) else False)\n",
    "    \n",
    "    #αντι να αλλαξω χαρακτηρα-χαρακτηρα ή να μπλέξω με το ποια στήλη είναι ποια, έφτιαξα ένα καινούριο λεξικό\n",
    "    dct[i] = {}\n",
    "    for x, y in zip(pd.Series(p[i])[bma_mask[i]], pd.Series(q[i])[bma_mask[i]]):\n",
    "        dct[i].update({y : x})\n",
    "    for x, y in zip(pd.Series(p[i])[pres_mask[i]], pd.Series(q[i])[pres_mask[i]]):\n",
    "        dct[i].update({x : y})\n",
    "    \n",
    "    #αλλαζει το όνομα σε όσες στήλες του έχω πει στο λεξικό, ε΄ίναι όλες ιδιες τωρα πια\n",
    "    months[i].rename(columns=dct[i], inplace=True)\n",
    "    #μην του δίνετε σημασία, γενικα το dct[3] έιναι το καλύτερο και θα μπορούσαμε να φτιάξουμε μόνο αυτο\n",
    "    #και να το περασουμε σε ολους τους μηνες απλα προτίμησα να το κανω με πινακακια ωστε να κραταω ολες \n",
    "    #τις πληροφοριες που δημιουργουνται στο ενδιαμεσο για να μη μου ξεφυγει κατι\n",
    "    #τα dct[0, 1, 2] δεν περιεχουν τιποτα γιατι δεν υπήρχαν λάθη στις πρωτες 94 στηλες και γι αυτο εβαλα το dct[3]\n",
    "    if i==3:\n",
    "        months[0].rename(columns=dct[i], inplace=True)\n",
    "        months[1].rename(columns=dct[i], inplace=True)\n",
    "        months[2].rename(columns=dct[i], inplace=True)\n",
    "        \n",
    "#\"ένωση\" στηλών με το ίδιο όνομα:\n",
    "double_cols = months[2].iloc[:, months[2].columns.duplicated()].columns\n",
    "for col in double_cols:\n",
    "    months[2][col] = months[2][col].mean(axis = 1, skipna = True)\n",
    "months[2] = months[2].iloc[:, ~months[2].columns.duplicated()]\n",
    "\n",
    "for i in range(6):\n",
    "    months[i] = months[i].reset_index().drop_duplicates().sort_values(by = 'date')\n",
    "    months[i].set_index('date', inplace=True)\n",
    "\n",
    "df = pd.concat([months[i] for i in range(6)])\n",
    "df.drop(columns = ['total_feed_perc_pv', 'mill_operation'], inplace=True)\n",
    "\n",
    "df.to_csv(r'MonthsDF.csv')"
   ]
  }
 ],
 "metadata": {
  "colab": {
   "collapsed_sections": [
    "ne7_O8dc1HEz",
    "tg6IpOoK0qol",
    "CVJ-R9Wndwlr",
    "oMuj8XuVdwmJ"
   ],
   "name": "Project_f.ipynb",
   "provenance": []
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
